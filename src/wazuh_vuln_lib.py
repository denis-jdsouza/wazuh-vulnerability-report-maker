"""Common library for 'wazuh_vuln_report' utilities.
\nConnects to Wazuh manager API, retrieves vulnerability data, formats it and generates reports.
\nEnsure credentials have been set as environment variables before running the tool.

Referenced from:
https://documentation.wazuh.com/current/user-manual/api/index.html

The wazuh_api_calls() function takes arguments in the form of optional filter terms,
formatted as '&<type>=<term>' for each of package name, severity, CVE, or
agent group name (or blank strings '' for any or all terms not used), and
returns:
\n-a [list] of agent IDs, as strings
\n-a [list] of agent names, as strings
\n-a {dict} of vulnerabilities, indexed by agent ID

The ProcessInfo() class takes arguments as:
\n-the [list] of agent IDs,
\n-the {dict} of vulnerabilities,
\n-one of the strings 'Name'|'Severity'|'CVE'

and creates a [list] of (tuples) of a total number of results and the
accompanying term, accessible as <classname>.item_tuple once the class is
created.
"""


import json
import sys
from base64 import b64encode
import requests
from urllib3 import disable_warnings
from urllib3.exceptions import InsecureRequestWarning


def wazuh_api_calls(filters: str, group: str, wazuh_creds: dict):
    """Make API calls to Wazuh server for retrieval of information."""

    # Disable insecure https warnings (for self-signed SSL certificates)
    disable_warnings(InsecureRequestWarning)

    # Configuration
    protocol = 'https'
    host = wazuh_creds.get('w_host')
    port = 55000
    user = wazuh_creds.get('w_user')
    password = wazuh_creds.get('w_passwd')
    timeout_seconds = 30
    login_endpoint = 'security/user/authenticate'
    login_url = f"{protocol}://{host}:{port}/{login_endpoint}"
    basic_auth = f"{user}:{password}".encode()
    login_headers = {'Content-Type': 'application/json',
                     'Authorization': f'Basic {b64encode(basic_auth).decode()}'}

    # API call with login to get auth token
    response = requests.get(login_url, headers=login_headers,
                            verify=False, timeout=timeout_seconds)
    response.raise_for_status()
    token = json.loads(response.content.decode())['data']['token']

    # New authorization header with the JWT token we got
    requests_headers = {'Content-Type': 'application/json',
                        'Authorization': f'Bearer {token}'}

    # Retrieve list of active agents from the server for querying
    # vulns, filter output by group if specified.

    login_endpoint = f"agents/?status=active&select=id,os.platform,name{group}"
    login_url = f"{protocol}://{host}:{port}/{login_endpoint}"
    response = requests.get(
        login_url, headers=requests_headers, verify=False, timeout=timeout_seconds)
    response.raise_for_status()
    jlist = json.loads(response.content.decode())
    # Store agent IDs and names separately
    active_agents = [i['id'] for i in jlist['data']['affected_items']]
    agent_names = [n['name'] for n in jlist['data']['affected_items']]
    agent_oss = [n['os']['platform'] for n in jlist['data']['affected_items']]
    agent_oss_dict = dict(zip(active_agents, agent_oss))

    # Retrieve list of vulnerabilities for each active agent,
    # filtering with any supplied arguments; format {&argtype=[arg]}

    vulns = {}
    login_endpoint = f"?limit=10000&select=cve,name,severity,condition{filters}"
    login_url = f"{protocol}://{host}:{port}/vulnerability/"
    for k in active_agents:
        response = requests.get(f"{login_url}{k}{login_endpoint}",
                                headers=requests_headers, verify=False, timeout=timeout_seconds)
        response.raise_for_status()
        # Store data in dict() indexed by agent ID
        vulns[k] = json.loads(response.content.decode())

    return active_agents, agent_names, agent_oss_dict, vulns


class ProcessInfo():
    """Class to extract and compile a specific type of data from bulk
    vulnerability information.
    """

    def __init__(
        self,
        agents: list,
        vulns: dict,
        type_filter: str
    ):
        self.type_filter = type_filter
        self.item_tuple = self.process_info(agents, vulns)

    def process_info(self, agents, vulns):
        """Process vulnerability metadata from each
        agent and compile a list of unique entries, with counts.
        """
        item_compendium = []
        # Place all values of matching type into a list, then create
        # a list of unique values, then count occurrences of each value.

        for agent in agents:
            item_compendium.extend([
                vuln[self.type_filter.lower()] for vuln
                in vulns[agent]['data']['affected_items']
            ])

        item_header = set(item_compendium)

        # Remove 'Untriaged' type vulnerability if present
        if self.type_filter == 'Severity' and 'Untriaged' in item_header:
            item_header.remove('Untriaged')

        item_occurrence = [item_compendium.count(item) for item in item_header]

        item_tuple = tuple(zip(item_header, item_occurrence))

        # End program early if no matches detected
        if len(item_tuple) == 0:
            print('No results found.')
            sys.exit()

        return sorted(item_tuple, key=lambda item: item[1], reverse=True)
